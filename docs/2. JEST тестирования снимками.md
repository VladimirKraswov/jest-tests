# Тестирование React приложений с помощью **JEST** и Testing Library

## JEST

В отличие от **Mocha**, **Jest** довольно прост в настройке, интеграции в проект и при этом довольно функционален. Это молодой проект, который еще не так давно сильно отставал от **Mocha** и **Karma** : в нем отсутствовало многое из необходимой для тестов функциональности, например, не было тестирования асинхронных функций или watch-режима, который следил бы за изменяемыми файлами. Сейчас этот инструмент приобрел многие возможности и способен потягаться как с **Mocha** так и с **Karma**. 

Плюсы и возможности **Jest**:

* Удивительно прост в интеграции в проект
Не нужно ставить десяток мелких библиотек и настраивать их взаимодействие между собой, так как Jest уже содержит в себе все необходимое.
* Запуск тестов и вывод результатов тестирования
Jest содержит достаточно параметров для настройки поиска и запуска тестов, так что вы всегда сможете настроить его для вашего проекта и задач.
* Содержит assert-библиотеку, которую, тем не менее, можно заменить любой другой
Jest базируется на второй версии библиотеки **Jasmine**, так что если вы когда-то работали с ней, то синтаксис покажется знакомым. Если же вам не нравится **Jasmine**, вы можете использовать свою любимую библиотеку.
* Умеет запускать каждый тест в отдельном процессе, ускоряя тем самым выполнение тестов
* Умеет работать с асинхронным кодом и тестировать код, использующий таймеры
* Умеет автоматически создавать «заглушки» для импортируемых компонентов
По сути, это одна из killer-фич **Jest**, но довольно сложная для настройки. Именно из-за нее многие в свое время отказались от использования **Jest**, и в новых версиях она теперь отключена по умолчанию.
* Умеет работать в интерактивном watch-режиме
* **Jest** имеет довольно крутой интерактивный режим, позволяющий вам запускать не только тесты на изменившиеся компоненты, но и, например, из последнего коммита в git, последние «провалившиеся» тесты или же с использованием «паттерна» для поиска по имени.
* Умеет собирать покрытие проекта тестами (coverage)
* Содержит jsdom и, как следствие, умеет запускать тесты без браузера
* Умеет тестировать компоненты с использованием снимков (snapshot)

## React Testing Library

**React Testing Library** — это набор вспомогательных функций, позволяющий тестировать React-компоненты не полагаясь на их внутреннюю реализацию. Такой подход упрощает рефакторинг, а также подталкивает вас применять лучшие практики по улучшению доступности. Библиотека идет в комплекте с React. Официальная документация - https://testing-library.com/

## Настройка и запуск

При создании приложения с помощью Create React App, ****JEST**** + **React Testing Library** и начальные настройки идут по умолчанию. Единственное что может понадобится доустановить вспомогательные библиотеки по необходимости. Например такие:

* **react-test-renderer** - Этот пакет предоставляет экспериментальный рендеринг React, который можно использовать для рендеринга компонентов React в объекты чистого JavaScript, не зависящие от DOM или родной мобильной среды.
По сути, этот пакет позволяет легко получить снимок "дерева DOM", отображаемого React DOM или компонентом React Native, без использования браузера или jsdom. Если вы используете React Testing Library то там есть своя реализация подобного функционала 
* **Chai** – библиотека, предоставляющая множество функций проверки утверждений. Наподобие assert.equal.
* **Sinon** – библиотека, позволяющая наблюдать за функциями, эмулировать встроенные функции и многое другое.
* **msw** - Моковый сервер
* **Enzyme** – это библиотека JavaScript, разработанная компанией Airbnb, которая предоставляет удобные инструменты и API для тестирования React-компонентов. Enzyme позволяет разработчикам эффективно тестировать взаимодействие, состояние и структуру React-компонентов в изолированной среде тестов. С выходом React 18 более не поддерживается и считается <a href="https://dev.to/wojtekmaj/enzyme-is-dead-now-what-ekl">мертвым</a>.

Что бы запустить тесты просто наберите команду:

```bash
  yarn test
```

## Структура файла с тестами и минимальное тестирование

Реализуем тестирование компонента с помощью стандартных возможностей, предоставляемых Testing Library.

Таким образом минимальная структура может выглядеть так:

```js
import { render, screen } from '@testing-library/react';
import App from '../App';

test('Поля ввода электронной почты и пароля отображаются', () => {
    render(<App />); // Позволяет без браузера отрисовать DOM компонента
    const emailInput = screen.getByLabelText('Email:'); // Найти инпут в DOM к которому привязана метка "Email:"
    const passwordInput = screen.getByLabelText('Пароль:'); // Найти инпут в DOM к которому привязана метка "Пароль:"
    expect(emailInput).toBeInTheDocument(); // Проверить что инпут нашелся, присутствует на экране
    expect(passwordInput).toBeInTheDocument();
});
```

Обычно все файлы с тестами складываю в каталок `__tests__` структура внутри которого не важна, **JEST** сам находит файлы с пометкой test и запускает их:

```
__tests__
|__MyComponent.test.tsx
```

Для тестов **Jest** предоставляет две глобальные функции: **test/it** и **expect**. Они доступны без какого-либо импорта, так как Jest делает их глобальными функциями. Обратите внимания что test и it это одно и тоже, разница лиш в неймиге.

Функция **test** нужна для описания конкретного теста и его проверок. Самих тестовых функций может быть любое количество. Первым параметром эта функция принимает произвольную строчку, которая должна описывать сам тест. Эта строчка потом отображается на экране во время запуска тестов для упрощения отладки.

Второй параметр — функция, внутри которой описан проверочный код. Обратите внимание на то, что этот код не выполняется сразу. Функция test добавляет его внутрь **Jest**, который уже решает, как и когда запускать тесты. Это позволяет проводить различные оптимизации, например, выполнять тесты параллельно.

Данный пример находит в отрисованном компоненте инпуты с метками 'Email:' и 'Пароль:', после чего с помощью **матчера** expect проверяет присутствуют ли они в этом компоненте.

**матчер** это утверждения, имеющие особую структуру, напоминающую обращение к объекту. Общий принцип работы **матчеров** такой:

Вызывается функция **expect()**, куда передаётся актуальное (фактическое) значение.
На результате, возвращаемом функцией **expect()**, вызывается подходящий **матчер**, например, **toEqual**.
Описание всех **матчеров** можно найти в официальной документации jest https://jestjs.io/docs/using-matchers
Код с **матчерами** похож на обычные предложения на английском языке. Это сделано специально, чтобы их могли читать даже не программисты:

```js
// Ожидается, что результат выражения addingStrings('Hello', ' ',  'World') равен 'Hello World''
expect(addingStrings('Hello', ' ',  'World')).toEqual('Hello World');
```

Более продвинутая структура:

```js
import { render, screen } from '@testing-library/react';
import App from '../App';

describe('App component', () => {
  // Выполнить перед началом всех тестов
  beforeAll(() => {
    // CODE
  })

  // Выполнить перед началом тестирования любого it/test блока
  beforeEach(() => {
    // CODE
  })

  // Выполнить после тестирования любого it/test блока
  afterEach(() => {
    // CODE
  })

  // Выполнить после окончания всех тестов
  afterAll(() => {
    // CODE
  })

  it('Поля ввода электронной почты и пароля отображаются', () => {
    render(<App />);
    const emailInput = screen.getByLabelText('Email:');
    const passwordInput = screen.getByLabelText('Пароль:');
    expect(emailInput).toBeInTheDocument();
    expect(passwordInput).toBeInTheDocument();
  });
})
```

Здесь вы можете выполнять какие либо действия перед и после запуска тестового блока. Например вы можете:

* В beforeEach инициализировать стор
* В beforeEach монтировать компонент
* В beforeEach Инициализировать вспомогательные библиотеки, такие как Sinon а в afterEach освобождать их

Теперь проверим успешное заполнение полей ввода

```js
  it('Поле email корректно обрабатывает ввод', () => {
    render(<App />);
    const emailInput = screen.getByLabelText('Email:'); // Находим поле по названию метки
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } }); // Заполняем поле
    expect(emailInput).toHaveValue('test@example.com'); // Убеждаемся что поле заполнилось верными данными
  });

  it('Поле password корректно обрабатывает ввод', () => {
    render(<App />);
    const passwordInput = screen.getByLabelText('Пароль:');
    fireEvent.change(passwordInput, { target: { value: 'password123' } });
    expect(passwordInput).toHaveValue('password123');
  });
```

Здесь для имитации заполнения мы с помощью <a href="https://testing-library.com/docs/user-event/intro/#differences-from-fireevent">fireEvent</a> меняем данные внутри DOM, для полной имитации пользовательского ввода применяется userEvent

```js
import userEvent from '@testing-library/user-event'

// inlining
test('trigger some awesome feature when clicking the button', async () => {
  const user = userEvent.setup()
  // Import `render` and `screen` from the framework library of your choice.
  // See https://testing-library.com/docs/dom-testing-library/install#wrappers
  render(<MyComponent />)

  await user.click(screen.getByRole('button', {name: /click me!/i}))

  // ...assertions...
})
```

### Тестирование ответа от сервера

Для тестирования отправки запроса на сервер и получения от него ответа необходим фиктивный (mock) сервер например <a href="https://www.npmjs.com/package/msw">msw</a>. Но одним из самых простых решений для этого будет подмена стандартного fetch вашим промисом:

```js
  global.fetch = () => (new Promise((resolve) => {
    resolve({ status: 200 } as Response)
  }))
```

Давайте протестируем успешный и не успешный запрос.

```js
// Минимальные JEST тесты
import React from 'react';
import { render, fireEvent, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event'

import App from '../App';

describe('Тест компонента App', () => {
  it('Успешный запрос', async () => {
    // Мокируем fetch для имитации ответа от сервера
    global.fetch = () => (new Promise((resolve) => {
      resolve({ status: 200 } as Response)
    }))

    render(<App />); // рендерим компонент
    const button = screen.getByText('Зарегистрироваться') // Находим кнопку по тексту

    expect(button).toBeInTheDocument(); // Проверяем, что компонент отображает кнопку

    userEvent.click(button); // имитируем нажатие кнопки для отправки запроса

    // Дожидаемся, пока отработает fetch запрос и данные компонента изменятся
    await waitFor(async () => {
      screen.getByText('Регистрация успешна'); // Убеждаемся что мы находим такой текст
    });
  });

  it('Не успешный запрос', async () => {
    // Мокируем fetch для имитации ошибки ответа от сервера
    global.fetch = () => { throw new Error("Something went wrong") }

    render(<App />); // рендерим компонент
    const button = screen.getByText('Зарегистрироваться') // Находим кнопку по тексту

    expect(button).toBeInTheDocument(); // Проверяем, что компонент отображает кнопку

    userEvent.click(button); // имитируем нажатие кнопки для отправки запроса

    // Дожидаемся, пока отработает fetch запрос и данные компонента изменятся
    await waitFor(async () => {
      screen.getByText('Ошибка при регистрации'); // Убеждаемся что мы находим такой текст
    });
  });
})
```

Здесь в случае успешного запроса содержимое старицы изменяется на текст  "Регистрация успешна" в случае неудачного запроса меняется на "Ошибка при регистрации". Мы подменяем стандартный fetch нашим промисом который возвращает статус 200 для успешного запроса и генерирует ошибку для не успешного. Затем мы отрисовываем наш компонент,  находим в нем по тексту элемент кнопку и с помощью userEvent имитируем клик мишки по кнопке.

> Ранее мы уже имитировали пользовательские действия когда заполняли поля email и password, тогда мы использовали **fireEvent**. Отличия в том что **fireEvent** отправляет события в DOM, тогда как **userEvent** имитирует полное взаимодействие, которое может запускать несколько событий и попутно выполнять дополнительные проверки.

После имитации клика мы должны дождатся завершения запроса и перерисовки компонента в соответствии с результатом запроса. 

Для этого применяется утилита waitFor, когда вам нужно проверить асинхронный код. Самый распространенный асинхронный код — это вызов API для получения данных во внешнем приложении ReactJS. Для возврата данных из конечной точки API обычно требуется одна-две секунды, но код React не может ждать это время. В этих сценариях мы используем Fetch API или Axios в ReactJS, который ожидает возврата данных из API. Но он также продолжает выполнять код после асинхронной задачи. Такое асинхронное поведение необходимо, поскольку JavaScript — однопоточный язык.

Этот код распространен практически во всех современных веб-приложениях, таких как социальные сети или электронная коммерция. Чтобы протестировать любое веб-приложение, нам нужно использовать waitFor, иначе поведение ReactJS/JavaScript продолжит работать с другими частями кода.

Поэтому для ожидания отработки API запроса мы применяем **waitFor** в которую передаем колбек отрабатывающий по истечению определенного времени. Подробнее про работу с тестированием асинхронного кода вы можите ознакомится в <a href="https://testing-library.com/docs/dom-testing-library/api-async/">официальной документации</a>.

## Snapshot-тестирование

**JEST** поддерживает несколько видов тестирования, один из них появился не так давно это Snapshot-тестирование.

Смысл заключается в том, что с помощью специальной проверочной функции мы просим Jest сохранить снимок нашей структуры данных на диск, а при последующих выполнениях теста сравнивать новые снимки с ранее сохраненным и при этом удачным тестом считается тот при котором новый снимок не отличается от старого.

### Плюсы

* Такое тестирование хорошо подходит там, где нет никакой интерактивности и нужно, по сути, просто проверить структуру, в таком случае не надо дублировать код в тестах.
* Это быстро, не нужно тратить много времени на написания тестов

### Минусы

* Тесты – это часто своего рода документация кода, а тестирование на основе снимков, по сути, дает возможность «схалявить» и, не задумываясь об assert-ах, просто сравнить два дерева компонента.
* Лишает возможности классического TDD, когда сначала пишут тесты компонента, а потом пишу сам код.

### Структура

Снимок не что иное, как просто текстовое представление данных.
Например, вот так будет выглядеть снимок какого-нибудь объекта (ключ массива тут является названием теста):

```js
exports[`some test name`] = `переквалифицироватся
Object {
    "Hello": "world"
}
`;
```

Вот так выглядит проверочная функция Jest, которая выполняет сравнение снимков (параметры необязательные):

```js
expect(value).toMatchSnapshot(propertyMatchers, snapshotName)
```

В качестве value может выступать любая сериализуемая структура данных. В первый раз функция toMatchSnapshot() просто запишет снимок на диск в каталог `__snapshots__`, в последующие разы она уже будет выполнять сравнение, поэтому следует обратить внимание на то что бы эти снимки не были проигнорированны гитом и запушены вместе с кодом.

Чаще всего такая технология тестирования используется именно для тестирования React-компонентов, а еще более точно, для тестирования правильности рендеринга React-компонентов. Для этого в качестве value нужно передавать компонент после рендеринга.

Для теста давайте протестируем компонент Link

```ts
// Link.tsx
import {FC, useState} from 'react';

const STATUS = {
  HOVERED: 'hovered',
  NORMAL: 'normal',
};

interface ILinkProps {
  page: string
  children: React.ReactElement | string
}

export const  Link: FC<ILinkProps> = ({ page, children }) => {
  const [status, setStatus] = useState(STATUS.NORMAL);

  const onMouseEnter = () => {
    setStatus(STATUS.HOVERED);
  };

  const onMouseLeave = () => {
    setStatus(STATUS.NORMAL);
  };

  return (
    <a
      className={status}
      href={page || '#'}
      onMouseEnter={onMouseEnter}
      onMouseLeave={onMouseLeave}
    >
      {children}
    </a>
  );
}
```

```ts
// Link.test.tsx
// Тестирование при помощи снимков
import React from 'react';
import renderer from 'react-test-renderer';

import { Link } from '../components/Link/Link';

it('Изменяет состояние при наведении курсора', () => {
  const component = renderer.create(
    <Link page="login">Login</Link>,
  );
  // Проверяем что снимки совпадают
  let tree: any = component.toJSON();
  expect(tree).toMatchSnapshot();

  // Имитируем наведение мышкой
  renderer.act(() => {
    tree.props.onMouseEnter();
  });
  // Проверяем что снимки совпадают
  tree = component.toJSON();
  expect(tree).toMatchSnapshot();

  // Имитируем уход мышки
  renderer.act(() => {
    tree?.props.onMouseLeave();
  });
  // Проверяем что снимки совпадают
  tree = component.toJSON();
  expect(tree).toMatchSnapshot();
});
```
